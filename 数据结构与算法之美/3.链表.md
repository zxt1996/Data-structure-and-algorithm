# 链表(上)：如何实现LRU缓存淘汰算法
链表通过“指针”将一组**零散的内存块**串联起来使用  

![](img/链表内存使用.jpg)

## 单链表
![](img/单链表.jpg)  

![](img/链表插入删除.jpg)

## 循环链表
![](img/循环链表.jpg)

## 双向链表
![](img/双向链表.jpg)  

![](img/双向循环链表.jpg)

## 链表VS数组性能
![](img/链表VS数组性能.jpg)

# 链表(下)：如何轻松写出正确的链表代码

## 技巧一：理解指针或引用的含义
**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量**

## 技巧二：警惕指针丢失和内存泄漏
![](img/链表插入元素a.jpg)  

```
x->next = p->next; //将x的结点的next指针指向b结点
p->next = x; //将p的next指针指向x节点
```
**插入节点时，一定要注意操作的顺序**


